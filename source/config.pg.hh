/*
 * This is free and unencumbered software released into the public domain.
 * 
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 * 
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * 
 * For more information, please refer to <http://unlicense.org>
 */

// AUTO-GENERATED FILE. DO NOT EDIT!
// Generated by the protogen 1.0.0 compiler <https://github.com/brunexgeek/protogen>
// Source: /media/dados/projetos/dns-blocker/source/config.proto

#ifndef GUARD__media_dados_projetos_dns_blocker_source_config_proto
#define GUARD__media_dados_projetos_dns_blocker_source_config_proto

#if !defined(_WIN32) && !defined(_WIN64)
   #pragma GCC diagnostic ignored "-Wunused-function"
#endif
#ifdef PROTOGEN_VERSION
   #undef PROTOGEN_VERSION
#endif

#define PROTOGEN_CPP_ENABLE_ERRORS // enable parsing error information

#include <string>
#include <cstring>
#include <stdint.h>
#include <iterator>
#include <sstream>
#include <iostream>
#include <vector>
#include <cstdlib>
#include <locale.h>
#include <stdexcept>

#undef PROTOGEN_NS
#define PROTOGEN_NS protogen_1_0_0

#ifndef PROTOGEN_CPP_ENABLE_ERRORS
    #define PROTOGEN_REV(err,input,name,type) return false
    #define PROTOGEN_REI(err,input,name) return false
    #define PROTOGEN_REF(err,input,name) return false
    #define PROTOGEN_REM(err,input,name) return false
    #define PROTOGEN_REG(err,input,name) return false
#else
    #define PROTOGEN_REV(err,input,name,type) \
        do { if (err == NULL || err->set) return false; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = std::string("Invalid '") + type + "' value in field '" + name + "'"; \
             return false; } while(false)
    #define PROTOGEN_REI(err,input,name) \
        do { if (err == NULL || err->set) return false; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = std::string("Unable to skip field '") + name + "'"; \
             return false; } while(false)
    #define PROTOGEN_RETERR_FORMAT(err,input,name) \
        do { if (err == NULL || err->set) return false; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = std::string("Invalid JSON after field '") + name + "'"; \
             return false; } while(false)
    #define PROTOGEN_REM(err,input,name) \
        do { if (err == NULL || err->set) return false; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = std::string("Missing required field '") + name + "'"; \
             return false; } while(false)
    #define PROTOGEN_REG(err,input,msg) \
        do { if (err == NULL || err->set) return false; \
             err->set = true; \
             err->line = input.line(); err->column = input.column(); \
             err->message = msg; \
             return false; } while(false)
#endif

#undef PROTOGEN_TRAIT_MACRO
#define PROTOGEN_TRAIT_MACRO(MSGTYPE) \
	namespace PROTOGEN_NS { \
		template<> struct traits<MSGTYPE> { \
			static void clear( MSGTYPE &value ) { value.clear(); } \
			static void write( std::ostream &out, const MSGTYPE &value ) { value.serialize(out); } \
			template<typename I> static bool read( PROTOGEN_NS::InputStream<I> &in, MSGTYPE &value, \
                bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) { return value.deserialize(in, required, err); } \
			static void swap( MSGTYPE &a, MSGTYPE &b ) { a.swap(b); } \
		}; \
	}

#undef PROTOGEN_FIELD_MOVECTOR_TEMPLATE
#if __cplusplus >= 201103L
#define PROTOGEN_FIELD_MOVECTOR_TEMPLATE(MSGTYPE) Field( Field<MSGTYPE> &&that ) { this->value_.swap(that.value_); }
#else
#define PROTOGEN_FIELD_MOVECTOR_TEMPLATE(MSGTYPE)
#endif

#undef PROTOGEN_FIELD_TEMPLATE
#define PROTOGEN_FIELD_TEMPLATE(MSGTYPE) \
	namespace PROTOGEN_NS { \
        template<> class Field<MSGTYPE> { \
		protected: \
			MSGTYPE value_; \
		public: \
			Field() { clear(); } \
			PROTOGEN_FIELD_MOVECTOR_TEMPLATE(MSGTYPE); \
			void swap( Field<MSGTYPE> &that ) { traits<MSGTYPE>::swap(this->value_, that.value_); } \
			const MSGTYPE &operator()() const { return value_; } \
			MSGTYPE &operator()() { return value_; } \
			void operator ()(const MSGTYPE &value ) { this->value_ = value; } \
			bool undefined() const { return value_.undefined(); } \
			void clear() { traits<MSGTYPE>::clear(value_); } \
			Field<MSGTYPE> &operator=( const Field<MSGTYPE> &that ) { this->value_ = that.value_; return *this; } \
			bool operator==( const MSGTYPE &that ) const { return this->value_ == that; } \
			bool operator==( const Field<MSGTYPE> &that ) const { return this->value_ == that.value_; } \
	    }; \
    }
#ifndef PROTOGEN_BASE_1_0_0
#define PROTOGEN_BASE_1_0_0


namespace PROTOGEN_NS {

enum FieldType
{
    TYPE_DOUBLE       =  6,
    TYPE_FLOAT        =  7,
    TYPE_INT32        =  8,
    TYPE_INT64        =  9,
    TYPE_UINT32       =  10,
    TYPE_UINT64       =  11,
    TYPE_SINT32       =  12,
    TYPE_SINT64       =  13,
    TYPE_FIXED32      =  14,
    TYPE_FIXED64      =  15,
    TYPE_SFIXED32     =  16,
    TYPE_SFIXED64     =  17,
    TYPE_BOOL         =  18,
    TYPE_STRING       =  19,
    TYPE_BYTES        =  20,
    TYPE_MESSAGE      =  21
};


struct ErrorInfo
{
    int line;
    int column;
    std::string message;
    bool set;

    ErrorInfo() : line(0), column(0), set(false) {}
};


template <typename I> class InputStream
{
    protected:
        I cur_, end_;
        int last_, line_, column_;
        bool ungot_;

    public:
        InputStream( const I& first, const I& last ) : cur_(first), end_(last),
            last_(-1), line_(1), column_(0), ungot_(false)
        {
        }

        bool eof()
        {
            return last_ == -2;
        }

        int get()
        {
            if (ungot_)
            {
                ungot_ = false;
                return last_;
            }
            if (last_ == '\n')
            {
                ++line_;
                column_ = 0;
            }
            if (cur_ == end_)
            {
                last_ = -2;
                return -1;
            }

            last_ = *cur_ & 0xFF;
            ++cur_;
            ++column_;
            return last_;
        }

        void unget()
        {
            if (last_ >= 0)
            {
                if (ungot_) throw std::logic_error("unable to unget");
                ungot_ = true;
            }
        }

        int cur() const { return *cur_; }

        int line() const { return line_; }

        int column() const { return column_; }

        void skipws()
        {
            while (1) {
                int ch = get();
                if (! (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r'))
                {
                    unget();
                    break;
                }
            }
        }

        bool expect(int expect)
        {
            if (get() != expect)
            {
                unget();
                return false;
            }
            return true;
        }
};

// proto3 numerics
template<typename T> struct traits
{
    static void clear( T &value ) { value = (T) 0; }
    static void write( std::ostream &out, const T &value ) { out << value; }
    template<typename I>
    static bool read( InputStream<I> &in, T &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        in.skipws();
        std::string temp;
        while (true)
        {
            int ch = in.get();
            if (ch != '.' && ch != '-' && (ch < '0' || ch > '9'))
            {
                in.unget();
                break;
            }
            temp += (char) ch;
        }
        if (temp.empty())
            return false;

#if defined(_WIN32) || defined(_WIN64)
        static _locale_t loc = _create_locale(LC_NUMERIC, "C");
        if (loc == NULL) return false;
        value = (T) _strtod_l(temp.c_str(), NULL, loc);
#else
        static locale_t loc = newlocale(LC_NUMERIC_MASK | LC_MONETARY_MASK, "C", 0);
        if (loc == 0) return false;
        uselocale(loc);
        value = (T) strtod(temp.c_str(), NULL);
        uselocale(LC_GLOBAL_LOCALE);
#endif
        return true;
    }
    static void swap( T &a, T &b ) { T temp = a; a = b; b = temp; }
};

// proto3 'bool'
template<> struct traits<bool>
{
    static void clear( bool &value ) { value = false; }
    static void write( std::ostream &out, const bool &value ) { out << ((value) ? "true" : "false"); }
    template<typename I>
    static bool read( InputStream<I> &in, bool &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        in.skipws();
        std::string temp;
        while (true)
        {
            int ch = in.get();
            switch (ch)
            {
                case 't':
                case 'r':
                case 'u':
                case 'e':
                case 'f':
                case 'a':
                case 'l':
                case 's':
                    temp += (char) ch;
                    break;
                default:
                    in.unget();
                    goto ESCAPE;
            }
        }
    ESCAPE:
        if (temp == "true")
            value = true;
        else
        if (temp == "false")
            value = false;
        else
            return false;
        return true;
    }
    static void swap( bool &a, bool &b ) { bool temp = a; a = b; b = temp; }
};

// proto3 'string'
template<> struct traits<std::string>
{
    static void clear( std::string &value ) { value.clear(); }
    static void write( std::ostream &out, const std::string &value )
    {
        out << '"';
        for (std::string::const_iterator it = value.begin(); it != value.end(); ++it)
        {
            switch (*it)
            {
                case '"':  out << "\\\""; break;
                case '\\': out << "\\\\"; break;
                case '/':  out << "\\/"; break;
                case '\b': out << "\\b"; break;
                case '\f': out << "\\f"; break;
                case '\r': out << "\\r"; break;
                case '\n': out << "\\n"; break;
                case '\t': out << "\\t"; break;
                default:   out << *it;
            }
        }
        out << '"';
    }
    template <typename I>
    static bool read( InputStream<I> &in, std::string &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        in.skipws();
        if (in.get() != '"') return false;
        while (true)
        {
            int ch = in.get();
            if (ch == '"') return true;

            if (ch == '\\')
            {
                ch = in.get();
                switch (ch)
                {
                    case '"':  ch = '"'; break;
                    case '\\': ch = '\\'; break;
                    case '/':  ch = '/'; break;
                    case 'b':  ch = '\b'; break;
                    case 'f':  ch = '\f'; break;
                    case 'r':  ch = '\r'; break;
                    case 'n':  ch = '\n'; break;
                    case 't':  ch = '\t'; break;
                    default: return false;
                }
            }

            if (ch <= 0) return false;
            value += (char) ch;
        }

        return false;
    }
    static void swap( std::string &a, std::string &b ) { a.swap(b); }
};

// proto3 'repeated'
template <typename T> struct traits< std::vector<T> >
{
    static void clear( std::vector<T> &value ) { value.clear(); }

    static bool write( std::ostream &out, const std::vector<T> &value )
    {
        bool begin = true;
        out << '[';
        for (typename std::vector<T>::const_iterator it = value.begin(); it != value.end(); ++it)
        {
            if (!begin) out << ",";
            begin = false;
            traits<T>::write(out, *it);
        }
        out << ']';
        return true;
    }

    template<typename I>
    static bool read( InputStream<I> &in, std::vector<T> &value, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        in.skipws();
        if (in.get() != '[') return false;
        in.skipws();
        while (true)
        {
            T entry;
            if (!traits<T>::read(in, entry, required, err)) return false;
            value.push_back(entry);
            in.skipws();
            if (!in.expect(',')) break;
        }
        if (in.get() != ']') return false;

        return true;
    }

    static void swap( std::vector<T> &a, std::vector<T> &b ) { a.swap(b); }
};

// Base64 encoder/decoder based on Joe DF's implementation
// Original source at <https://github.com/joedf/base64.c> (MIT licensed)
static const char *B64_SYMBOLS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
template <> struct traits< std::vector<uint8_t> >
{
    static void clear( std::vector<uint8_t> &value ) { value.clear(); }

    static int b64_int( int ch )
    {
        if (ch == '+') return 62;
        if (ch == '/') return 63;
        if (ch == '=') return 64;
        if (ch >= '0' && ch <= '9') return ch + 4;
        if (ch >= 'A' && ch <= 'Z') return ch - 'A';
        if (ch >= 'a' && ch <= 'z') return (ch - 'a') + 26;
        return 0;
    }

    static bool write( std::ostream &out, const std::vector<uint8_t> &value )
    {
        char o[5] = { 0 };
        size_t i = 0;
        size_t size = value.size();

        out << '"';

        for (i = 0; i + 2 < size; i += 3)
        {
            o[0] = B64_SYMBOLS[ (value[i] & 0xFF) >> 2 ];
            o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) | ((value[i + 1] & 0xF0) >> 4) ];
            o[2] = B64_SYMBOLS[ ((value[i+1] & 0x0F) << 2) | ((value[i+2] & 0xC0) >> 6) ];
            o[3] = B64_SYMBOLS[ value[i+2] & 0x3F ];
            out << o;
        }

        if (size - i)
        {
            o[0] = B64_SYMBOLS[ (value[i] & 0xFF) >> 2 ];
            o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) ];
            o[2] = '=';
            o[3] = '=';

            if (size - i == 2)
            {
                o[1] = B64_SYMBOLS[ ((value[i] & 0x03) << 4) | ((value[i + 1] & 0xF0) >> 4) ];
                o[2] = B64_SYMBOLS[ ((value[i+1] & 0x0F) << 2) ];
            }

            out << o;
        }
        out << '"';

        return true;
    }

    template<typename I>
    static bool read( InputStream<I> &in, std::vector<uint8_t> &array, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL )
    {
        (void) required;
        (void) err;
        size_t k = 0;
        int s[4];

        if (in.get() != '"') return false;

        while (true)
        {
            // read 4 characters
            for (size_t j = 0; j < 4; ++j)
            {
                int ch = in.get();
                if (ch == '"') return j == 0;
                s[j] = PROTOGEN_NS::traits< std::vector<uint8_t> >::b64_int(ch);
            }
            // decode base64 tuple
            array.push_back( ((s[0] & 0xFF) << 2 ) | ((s[1] & 0x30) >> 4) );
            if (s[2] != 64)
            {
                array.push_back( ((s[1] & 0x0F) << 4) | ((s[2] & 0x3C) >> 2) );
                if ((s[3]!=64))
                {
                    array.push_back( ((s[2] & 0x03) << 6) | s[3] );
                    k+=3;
                }
                else
                    k+=2;
            }
            else
                k+=1;
        }
    }

    static void swap( std::vector<uint8_t> &a, std::vector<uint8_t> &b ) { a.swap(b); }
};

// primitive fields
template<typename T> class Field
{
    protected:
        T value_;
        bool undefined_;
    public:
        Field() { clear(); }
        Field( const Field<T> &that ) { this->undefined_ = that.undefined_; if (!undefined_) this->value_ = that.value_; }
        #if __cplusplus >= 201103L
        Field( Field<T> &&that ) { this->undefined_ = that.undefined_; if (!undefined_) this->value_.swap(that.value_); }
        #endif
        void swap( Field<T> &that ) { traits<T>::swap(this->value_, that.value_); traits<bool>::swap(this->undefined_, that.undefined_); }
        const T &operator()() const { return value_; }
        void operator ()(const T &value ) { this->value_ = value; this->undefined_ = false; }
        bool undefined() const { return undefined_; }
        void clear() { traits<T>::clear(value_); undefined_ = true; }
        Field<T> &operator=( const Field<T> &that ) { this->undefined_ = that.undefined_; if (!undefined_) this->value_ = that.value_; return *this; }
        bool operator==( const T &that ) const { return !this->undefined_ && this->value_ == that; }
        bool operator==( const Field<T> &that ) const { return this->undefined_ == that.undefined_ && this->value_ == that.value_;  }
};

template<typename T> class RepeatedField
{
    protected:
        std::vector<T> value_;
    public:
        RepeatedField() {}
        RepeatedField( const RepeatedField<T> &that ) { this->value_ = that.value_; }
        #if __cplusplus >= 201103L
        RepeatedField( RepeatedField<T> &&that ) { this->value_.swap(that.value_); }
        #endif
        void swap( RepeatedField<T> &that ) { traits< std::vector<T> >::swap(this->value_, that.value_); }
        const std::vector<T> &operator()() const { return value_; }
        std::vector<T> &operator()() { return value_; }
        bool undefined() const { return value_.size() == 0; }
        void clear() { value_.clear(); }
        RepeatedField<T> &operator=( const RepeatedField<T> &that ) { this->value_ = that.value_; return *this; }
        bool operator==( const RepeatedField<T> &that ) const { return this->value_ == that.value_; }
};

#ifdef PROTOGEN_CPP_ENABLE_PARENT

class Message
{
    public:
        virtual void serialize( std::string &out ) const = 0;
        virtual void serialize( std::vector<char> &out ) const = 0;
        virtual void serialize( std::ostream &out ) const = 0;
        virtual bool deserialize( std::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL  ) = 0;
        virtual bool deserialize( const std::string &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL  ) = 0;
        virtual bool deserialize( const std::vector<char> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL  ) = 0;
        virtual void clear() = 0;
        virtual bool undefined() const = 0;
};

#endif // PROTOGEN_CPP_ENABLE_PARENT

namespace json {

#ifdef PROTOGEN_OBFUSCATE_STRINGS

static std::string reveal( const char *value, size_t length )
{
	std::string result(length, ' ');
	for (size_t i = 0; i < length; ++i)
		result[i] = (char) ((int) value[i] ^ 0x33);
	return result;
}

#endif

// Write a complete JSON field
template<typename T>
static bool write( std::ostream &out, bool &first, const std::string &name, const T &value )
{
    if (!first) out << ',';
    out << '"' << name << "\":";
    traits<T>::write(out, value);
    first = false;
    return true;
}

template<typename I>
static bool next( InputStream<I> &in )
{
    in.skipws();
    int ch = in.get();
    if (ch == ',') return true;
    if (ch == '}' || ch == ']')
    {
        in.unget();
        return true;
    }
    return false;
}

template<typename I>
static bool readName( InputStream<I> &in, std::string &name )
{
    if (!traits<std::string>::read(in, name)) return false;
    in.skipws();
    return (in.get() == ':');
}

template<typename I>
static bool ignoreString( InputStream<I> &in )
{
    if (in.get() != '"') return false;

    while (!in.eof())
    {
        int ch = in.get();
        if (ch == '\\')
        {
            int ch = in.get();
            switch (ch)
            {
                case '"':
                case '\\':
                case '/':
                case 'b':
                case 'f':
                case 'r':
                case 'n':
                case 't':
                    break;
                default: // invalid escape sequence
                    return false;
            }
        }
        else
        if (ch == '"')
            return true;
    }

    return false;
}

template<typename I>
static bool ignoreEnclosing( InputStream<I> &in, int begin, int end )
{
    if (in.get() != begin) return false;

    int count = 1;

    bool text = false;
    while (count != 0 && !in.eof())
    {
        int ch = in.get();
        if (ch == '"' && !text)
        {
            in.unget();
            if (!ignoreString(in)) return false;
        }
        else
        if (ch == end)
            --count;
        else
        if (ch == begin)
            ++count;
    }

    return count == 0;
}

template<typename I>
static bool ignore( InputStream<I> &in )
{
    in.skipws();
    int ch = in.get();
    in.unget();
    if (ch == '[')
        return ignoreEnclosing(in, '[', ']');
    else
    if (ch == '{')
        return ignoreEnclosing(in, '{', '}');
    else
    if (ch == '"')
        return ignoreString(in);
    else
    {
        while (!in.eof())
        {
            int ch = in.get();
            if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' || ch == ',' || ch == ']' || ch == '}')
            {
                in.unget();
                return true;
            }
        }
    }

    return false;
}

} // namespace json
} // namespace PROTOGEN_NS

#endif // PROTOGEN_BASE_1_0_0

// forward declarations
	class NameServer;
	class Binding;
	class Cache;
	class Configuration;

//
// NameServer
//

class NameServer {
public:
	typedef PROTOGEN_NS::ErrorInfo ErrorInfo;
	static const uint32_t PROTOGEN_VERSION = 0x010000;
	#undef PROTOGEN_FN_address
	#define PROTOGEN_FN_address "address"
	#undef PROTOGEN_FN_targets
	#define PROTOGEN_FN_targets "targets"
	static const int ADDRESS_NO = 1;
	PROTOGEN_NS::Field<std::string> address;
	static const int TARGETS_NO = 2;
	PROTOGEN_NS::RepeatedField<std::string> targets;
	NameServer() {}
	~NameServer() {}
	NameServer(const NameServer &that) { *this = that; }
	#if __cplusplus >= 201103L
	NameServer(NameServer &&that) {
		this->address.swap(that.address);
		this->targets.swap(that.targets);
	}
	#endif
	NameServer &operator=(const NameServer &that) {
		this->address = that.address;
		this->targets = that.targets;
		return *this;
	}
	void swap(NameServer &that) {
		this->address.swap(that.address);
		this->targets.swap(that.targets);
	}
	bool operator==(const NameServer &that) const {
		return
			this->address == that.address &&
			this->targets == that.targets;
	}
	bool undefined() const {
		return
			this->address.undefined() &&
			this->targets.undefined();
	}
	void serialize( std::string &out ) const {
		std::stringstream ss;
		serialize(ss);
		out = ss.str();
	}
	void serialize( std::vector<char> &out ) const {
		std::string temp;
		serialize(temp);
		out.resize(temp.length());
		memcpy(&out.front(), temp.c_str(), temp.length());
	}
	void serialize( std::ostream &out ) const {
		out << '{';
		bool first = true;
		// address
		if (!this->address.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_address, this->address());
		// targets
		if (!this->targets.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_targets, this->targets());
		out << '}';
	}
	bool deserialize( std::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		bool skip = in.flags() & std::ios_base::skipws;
		std::noskipws(in);
		std::istream_iterator<char> itb(in);
		std::istream_iterator<char> ite;
		PROTOGEN_NS::InputStream< std::istream_iterator<char> > is(itb, ite);
		bool result = this->deserialize(is, required, err);
		if (skip) std::skipws(in);
		return result;
	}
	bool deserialize( const std::string &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::InputStream<std::string::const_iterator> is(in.begin(), in.end());
		return this->deserialize(is, required, err);
	}
	bool deserialize( const std::vector<char> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::InputStream<std::vector<char>::const_iterator> is(in.begin(), in.end());
		return this->deserialize(is, required, err);
	}
	template <typename IT>
	bool deserialize( IT begin, IT end, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ){
		PROTOGEN_NS::InputStream<IT> is(begin, end);
		return this->deserialize(is, required, err);
	}
	template<typename T>
	bool deserialize( PROTOGEN_NS::InputStream<T> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		(void) err;
		in.skipws();
		if (in.get() != '{') PROTOGEN_REG(err, in, "Invalid object");
		in.skipws();
		std::string name;
		bool hfld[2] = {false};
		while (true) {
			if (in.get() == '}') break;
			in.unget();
			name.clear();
			if (!PROTOGEN_NS::json::readName(in, name)) PROTOGEN_REG(err, in, "Invalid field name");
			// address
			if (name == PROTOGEN_FN_address) {
				std::string value;
				if (!PROTOGEN_NS::traits<std::string>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "string");
				this->address(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[0] = true;
			}
			else
			// targets
			if (name == PROTOGEN_FN_targets) {
				if (!PROTOGEN_NS::traits< std::vector<std::string> >::read(in, this->targets(), required, err)) PROTOGEN_REV(err, in, name, "repeated string");
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[1] = true;
			}
			else
			// ignore the current field
			{
				if (!PROTOGEN_NS::json::ignore(in)) PROTOGEN_REI(err, in, name);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
			}
		}
		if (required) {
			if (!hfld[0]) PROTOGEN_REM(err, in, PROTOGEN_FN_address);
			if (!hfld[1]) PROTOGEN_REM(err, in, PROTOGEN_FN_targets);
		}
		return true;
	}
	void clear() {
		this->address.clear();
		this->targets.clear();
	}
};
PROTOGEN_TRAIT_MACRO( ::NameServer)
PROTOGEN_FIELD_TEMPLATE( ::NameServer)
#undef PROTOGEN_FN_address
#undef PROTOGEN_FN_targets

//
// Binding
//

class Binding {
public:
	typedef PROTOGEN_NS::ErrorInfo ErrorInfo;
	static const uint32_t PROTOGEN_VERSION = 0x010000;
	#undef PROTOGEN_FN_address
	#define PROTOGEN_FN_address "address"
	#undef PROTOGEN_FN_port
	#define PROTOGEN_FN_port "port"
	static const int ADDRESS_NO = 1;
	PROTOGEN_NS::Field<std::string> address;
	static const int PORT_NO = 2;
	PROTOGEN_NS::Field<uint32_t> port;
	Binding() {}
	~Binding() {}
	Binding(const Binding &that) { *this = that; }
	#if __cplusplus >= 201103L
	Binding(Binding &&that) {
		this->address.swap(that.address);
		this->port = that.port;
	}
	#endif
	Binding &operator=(const Binding &that) {
		this->address = that.address;
		this->port = that.port;
		return *this;
	}
	void swap(Binding &that) {
		this->address.swap(that.address);
		this->port.swap(that.port);
	}
	bool operator==(const Binding &that) const {
		return
			this->address == that.address &&
			this->port == that.port;
	}
	bool undefined() const {
		return
			this->address.undefined() &&
			this->port.undefined();
	}
	void serialize( std::string &out ) const {
		std::stringstream ss;
		serialize(ss);
		out = ss.str();
	}
	void serialize( std::vector<char> &out ) const {
		std::string temp;
		serialize(temp);
		out.resize(temp.length());
		memcpy(&out.front(), temp.c_str(), temp.length());
	}
	void serialize( std::ostream &out ) const {
		out << '{';
		bool first = true;
		// address
		if (!this->address.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_address, this->address());
		// port
		if (!this->port.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_port, this->port());
		out << '}';
	}
	bool deserialize( std::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		bool skip = in.flags() & std::ios_base::skipws;
		std::noskipws(in);
		std::istream_iterator<char> itb(in);
		std::istream_iterator<char> ite;
		PROTOGEN_NS::InputStream< std::istream_iterator<char> > is(itb, ite);
		bool result = this->deserialize(is, required, err);
		if (skip) std::skipws(in);
		return result;
	}
	bool deserialize( const std::string &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::InputStream<std::string::const_iterator> is(in.begin(), in.end());
		return this->deserialize(is, required, err);
	}
	bool deserialize( const std::vector<char> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::InputStream<std::vector<char>::const_iterator> is(in.begin(), in.end());
		return this->deserialize(is, required, err);
	}
	template <typename IT>
	bool deserialize( IT begin, IT end, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ){
		PROTOGEN_NS::InputStream<IT> is(begin, end);
		return this->deserialize(is, required, err);
	}
	template<typename T>
	bool deserialize( PROTOGEN_NS::InputStream<T> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		(void) err;
		in.skipws();
		if (in.get() != '{') PROTOGEN_REG(err, in, "Invalid object");
		in.skipws();
		std::string name;
		bool hfld[2] = {false};
		while (true) {
			if (in.get() == '}') break;
			in.unget();
			name.clear();
			if (!PROTOGEN_NS::json::readName(in, name)) PROTOGEN_REG(err, in, "Invalid field name");
			// address
			if (name == PROTOGEN_FN_address) {
				std::string value;
				if (!PROTOGEN_NS::traits<std::string>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "string");
				this->address(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[0] = true;
			}
			else
			// port
			if (name == PROTOGEN_FN_port) {
				uint32_t value;
				if (!PROTOGEN_NS::traits<uint32_t>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "uint32");
				this->port(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[1] = true;
			}
			else
			// ignore the current field
			{
				if (!PROTOGEN_NS::json::ignore(in)) PROTOGEN_REI(err, in, name);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
			}
		}
		if (required) {
			if (!hfld[0]) PROTOGEN_REM(err, in, PROTOGEN_FN_address);
			if (!hfld[1]) PROTOGEN_REM(err, in, PROTOGEN_FN_port);
		}
		return true;
	}
	void clear() {
		this->address.clear();
		this->port.clear();
	}
};
PROTOGEN_TRAIT_MACRO( ::Binding)
PROTOGEN_FIELD_TEMPLATE( ::Binding)
#undef PROTOGEN_FN_address
#undef PROTOGEN_FN_port

//
// Cache
//

class Cache {
public:
	typedef PROTOGEN_NS::ErrorInfo ErrorInfo;
	static const uint32_t PROTOGEN_VERSION = 0x010000;
	#undef PROTOGEN_FN_ttl
	#define PROTOGEN_FN_ttl "ttl"
	#undef PROTOGEN_FN_limit
	#define PROTOGEN_FN_limit "limit"
	static const int TTL_NO = 1;
	PROTOGEN_NS::Field<int32_t> ttl;
	static const int LIMIT_NO = 2;
	PROTOGEN_NS::Field<int32_t> limit;
	Cache() {}
	~Cache() {}
	Cache(const Cache &that) { *this = that; }
	#if __cplusplus >= 201103L
	Cache(Cache &&that) {
		this->ttl = that.ttl;
		this->limit = that.limit;
	}
	#endif
	Cache &operator=(const Cache &that) {
		this->ttl = that.ttl;
		this->limit = that.limit;
		return *this;
	}
	void swap(Cache &that) {
		this->ttl.swap(that.ttl);
		this->limit.swap(that.limit);
	}
	bool operator==(const Cache &that) const {
		return
			this->ttl == that.ttl &&
			this->limit == that.limit;
	}
	bool undefined() const {
		return
			this->ttl.undefined() &&
			this->limit.undefined();
	}
	void serialize( std::string &out ) const {
		std::stringstream ss;
		serialize(ss);
		out = ss.str();
	}
	void serialize( std::vector<char> &out ) const {
		std::string temp;
		serialize(temp);
		out.resize(temp.length());
		memcpy(&out.front(), temp.c_str(), temp.length());
	}
	void serialize( std::ostream &out ) const {
		out << '{';
		bool first = true;
		// ttl
		if (!this->ttl.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_ttl, this->ttl());
		// limit
		if (!this->limit.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_limit, this->limit());
		out << '}';
	}
	bool deserialize( std::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		bool skip = in.flags() & std::ios_base::skipws;
		std::noskipws(in);
		std::istream_iterator<char> itb(in);
		std::istream_iterator<char> ite;
		PROTOGEN_NS::InputStream< std::istream_iterator<char> > is(itb, ite);
		bool result = this->deserialize(is, required, err);
		if (skip) std::skipws(in);
		return result;
	}
	bool deserialize( const std::string &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::InputStream<std::string::const_iterator> is(in.begin(), in.end());
		return this->deserialize(is, required, err);
	}
	bool deserialize( const std::vector<char> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::InputStream<std::vector<char>::const_iterator> is(in.begin(), in.end());
		return this->deserialize(is, required, err);
	}
	template <typename IT>
	bool deserialize( IT begin, IT end, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ){
		PROTOGEN_NS::InputStream<IT> is(begin, end);
		return this->deserialize(is, required, err);
	}
	template<typename T>
	bool deserialize( PROTOGEN_NS::InputStream<T> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		(void) err;
		in.skipws();
		if (in.get() != '{') PROTOGEN_REG(err, in, "Invalid object");
		in.skipws();
		std::string name;
		bool hfld[2] = {false};
		while (true) {
			if (in.get() == '}') break;
			in.unget();
			name.clear();
			if (!PROTOGEN_NS::json::readName(in, name)) PROTOGEN_REG(err, in, "Invalid field name");
			// ttl
			if (name == PROTOGEN_FN_ttl) {
				int32_t value;
				if (!PROTOGEN_NS::traits<int32_t>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "int32");
				this->ttl(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[0] = true;
			}
			else
			// limit
			if (name == PROTOGEN_FN_limit) {
				int32_t value;
				if (!PROTOGEN_NS::traits<int32_t>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "int32");
				this->limit(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[1] = true;
			}
			else
			// ignore the current field
			{
				if (!PROTOGEN_NS::json::ignore(in)) PROTOGEN_REI(err, in, name);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
			}
		}
		if (required) {
			if (!hfld[0]) PROTOGEN_REM(err, in, PROTOGEN_FN_ttl);
			if (!hfld[1]) PROTOGEN_REM(err, in, PROTOGEN_FN_limit);
		}
		return true;
	}
	void clear() {
		this->ttl.clear();
		this->limit.clear();
	}
};
PROTOGEN_TRAIT_MACRO( ::Cache)
PROTOGEN_FIELD_TEMPLATE( ::Cache)
#undef PROTOGEN_FN_ttl
#undef PROTOGEN_FN_limit

//
// Configuration
//

class Configuration {
public:
	typedef PROTOGEN_NS::ErrorInfo ErrorInfo;
	static const uint32_t PROTOGEN_VERSION = 0x010000;
	#undef PROTOGEN_FN_external_dns
	#define PROTOGEN_FN_external_dns "external_dns"
	#undef PROTOGEN_FN_binding
	#define PROTOGEN_FN_binding "binding"
	#undef PROTOGEN_FN_blacklist
	#define PROTOGEN_FN_blacklist "blacklist"
	#undef PROTOGEN_FN_monitoring
	#define PROTOGEN_FN_monitoring "monitoring"
	#undef PROTOGEN_FN_threads
	#define PROTOGEN_FN_threads "threads"
	#undef PROTOGEN_FN_cache
	#define PROTOGEN_FN_cache "cache"
	static const int EXTERNAL_DNS_NO = 1;
	PROTOGEN_NS::RepeatedField< ::NameServer> external_dns;
	static const int BINDING_NO = 2;
	PROTOGEN_NS::Field< ::Binding> binding;
	static const int BLACKLIST_NO = 3;
	PROTOGEN_NS::RepeatedField<std::string> blacklist;
	static const int MONITORING_NO = 4;
	PROTOGEN_NS::Field<std::string> monitoring;
	static const int THREADS_NO = 5;
	PROTOGEN_NS::Field<int32_t> threads;
	static const int CACHE_NO = 6;
	PROTOGEN_NS::Field< ::Cache> cache;
	Configuration() {}
	~Configuration() {}
	Configuration(const Configuration &that) { *this = that; }
	#if __cplusplus >= 201103L
	Configuration(Configuration &&that) {
		this->external_dns.swap(that.external_dns);
		this->binding.swap(that.binding);
		this->blacklist.swap(that.blacklist);
		this->monitoring.swap(that.monitoring);
		this->threads = that.threads;
		this->cache.swap(that.cache);
	}
	#endif
	Configuration &operator=(const Configuration &that) {
		this->external_dns = that.external_dns;
		this->binding = that.binding;
		this->blacklist = that.blacklist;
		this->monitoring = that.monitoring;
		this->threads = that.threads;
		this->cache = that.cache;
		return *this;
	}
	void swap(Configuration &that) {
		this->external_dns.swap(that.external_dns);
		this->binding.swap(that.binding);
		this->blacklist.swap(that.blacklist);
		this->monitoring.swap(that.monitoring);
		this->threads.swap(that.threads);
		this->cache.swap(that.cache);
	}
	bool operator==(const Configuration &that) const {
		return
			this->external_dns == that.external_dns &&
			this->binding == that.binding &&
			this->blacklist == that.blacklist &&
			this->monitoring == that.monitoring &&
			this->threads == that.threads &&
			this->cache == that.cache;
	}
	bool undefined() const {
		return
			this->external_dns.undefined() &&
			this->binding.undefined() &&
			this->blacklist.undefined() &&
			this->monitoring.undefined() &&
			this->threads.undefined() &&
			this->cache.undefined();
	}
	void serialize( std::string &out ) const {
		std::stringstream ss;
		serialize(ss);
		out = ss.str();
	}
	void serialize( std::vector<char> &out ) const {
		std::string temp;
		serialize(temp);
		out.resize(temp.length());
		memcpy(&out.front(), temp.c_str(), temp.length());
	}
	void serialize( std::ostream &out ) const {
		out << '{';
		bool first = true;
		// external_dns
		if (!this->external_dns.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_external_dns, this->external_dns());
		// binding
		if (!this->binding.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_binding, this->binding());
		// blacklist
		if (!this->blacklist.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_blacklist, this->blacklist());
		// monitoring
		if (!this->monitoring.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_monitoring, this->monitoring());
		// threads
		if (!this->threads.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_threads, this->threads());
		// cache
		if (!this->cache.undefined()) PROTOGEN_NS::json::write(out, first, PROTOGEN_FN_cache, this->cache());
		out << '}';
	}
	bool deserialize( std::istream &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		bool skip = in.flags() & std::ios_base::skipws;
		std::noskipws(in);
		std::istream_iterator<char> itb(in);
		std::istream_iterator<char> ite;
		PROTOGEN_NS::InputStream< std::istream_iterator<char> > is(itb, ite);
		bool result = this->deserialize(is, required, err);
		if (skip) std::skipws(in);
		return result;
	}
	bool deserialize( const std::string &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::InputStream<std::string::const_iterator> is(in.begin(), in.end());
		return this->deserialize(is, required, err);
	}
	bool deserialize( const std::vector<char> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		PROTOGEN_NS::InputStream<std::vector<char>::const_iterator> is(in.begin(), in.end());
		return this->deserialize(is, required, err);
	}
	template <typename IT>
	bool deserialize( IT begin, IT end, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ){
		PROTOGEN_NS::InputStream<IT> is(begin, end);
		return this->deserialize(is, required, err);
	}
	template<typename T>
	bool deserialize( PROTOGEN_NS::InputStream<T> &in, bool required = false, PROTOGEN_NS::ErrorInfo *err = NULL ) {
		(void) err;
		in.skipws();
		if (in.get() != '{') PROTOGEN_REG(err, in, "Invalid object");
		in.skipws();
		std::string name;
		bool hfld[6] = {false};
		while (true) {
			if (in.get() == '}') break;
			in.unget();
			name.clear();
			if (!PROTOGEN_NS::json::readName(in, name)) PROTOGEN_REG(err, in, "Invalid field name");
			// external_dns
			if (name == PROTOGEN_FN_external_dns) {
				if (!PROTOGEN_NS::traits< std::vector< ::NameServer> >::read(in, this->external_dns(), required, err)) PROTOGEN_REV(err, in, name, "repeated NameServer");
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[0] = true;
			}
			else
			// binding
			if (name == PROTOGEN_FN_binding) {
				 ::Binding value;
				if (!PROTOGEN_NS::traits< ::Binding>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "Binding");
				this->binding(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[1] = true;
			}
			else
			// blacklist
			if (name == PROTOGEN_FN_blacklist) {
				if (!PROTOGEN_NS::traits< std::vector<std::string> >::read(in, this->blacklist(), required, err)) PROTOGEN_REV(err, in, name, "repeated string");
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[2] = true;
			}
			else
			// monitoring
			if (name == PROTOGEN_FN_monitoring) {
				std::string value;
				if (!PROTOGEN_NS::traits<std::string>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "string");
				this->monitoring(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[3] = true;
			}
			else
			// threads
			if (name == PROTOGEN_FN_threads) {
				int32_t value;
				if (!PROTOGEN_NS::traits<int32_t>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "int32");
				this->threads(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[4] = true;
			}
			else
			// cache
			if (name == PROTOGEN_FN_cache) {
				 ::Cache value;
				if (!PROTOGEN_NS::traits< ::Cache>::read(in, value, required, err)) PROTOGEN_REV(err, in, name, "Cache");
				this->cache(value);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
				hfld[5] = true;
			}
			else
			// ignore the current field
			{
				if (!PROTOGEN_NS::json::ignore(in)) PROTOGEN_REI(err, in, name);
				if (!PROTOGEN_NS::json::next(in)) PROTOGEN_REI(err, in, name);
			}
		}
		if (required) {
			if (!hfld[0]) PROTOGEN_REM(err, in, PROTOGEN_FN_external_dns);
			if (!hfld[1]) PROTOGEN_REM(err, in, PROTOGEN_FN_binding);
			if (!hfld[2]) PROTOGEN_REM(err, in, PROTOGEN_FN_blacklist);
			if (!hfld[3]) PROTOGEN_REM(err, in, PROTOGEN_FN_monitoring);
			if (!hfld[4]) PROTOGEN_REM(err, in, PROTOGEN_FN_threads);
			if (!hfld[5]) PROTOGEN_REM(err, in, PROTOGEN_FN_cache);
		}
		return true;
	}
	void clear() {
		this->external_dns.clear();
		this->binding.clear();
		this->blacklist.clear();
		this->monitoring.clear();
		this->threads.clear();
		this->cache.clear();
	}
};
PROTOGEN_TRAIT_MACRO( ::Configuration)
PROTOGEN_FIELD_TEMPLATE( ::Configuration)
#undef PROTOGEN_FN_external_dns
#undef PROTOGEN_FN_binding
#undef PROTOGEN_FN_blacklist
#undef PROTOGEN_FN_monitoring
#undef PROTOGEN_FN_threads
#undef PROTOGEN_FN_cache
#undef PROTOGEN_OBFUSCATE_STRINGS
#undef PROTOGEN_CPP_ENABLE_PARENT
#undef PROTOGEN_CPP_ENABLE_ERRORS
#undef PROTOGEN_FIELD_MOVECTOR_TEMPLATE
#undef PROTOGEN_FIELD_TEMPLATE
#undef PROTOGEN_TRAIT_MACRO
#undef PROTOGEN_REV
#undef PROTOGEN_REI
#undef PROTOGEN_REF
#undef PROTOGEN_REM
#undef PROTOGEN_REG
#undef PROTOGEN_NS
#endif // GUARD__media_dados_projetos_dns_blocker_source_config_proto
